using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace SpacePi.Dashboard.Analyzer.Binding {
    /// <summary>
    /// A factory for bindable objects
    /// </summary>
    public record BindingFactory {
        /// <summary>
        /// The symbol defining the factory
        /// </summary>
        public INamedTypeSymbol Symbol;
        /// <summary>
        /// The attribute declaring an instance generated by the factory
        /// </summary>
        public INamedTypeSymbol DeclarativeAttribute;
        /// <summary>
        /// The attribute declaring a property to be bound to an instance
        /// </summary>
        public INamedTypeSymbol BindingAttribute;
        /// <summary>
        /// The array property storing the instances in the factory
        /// </summary>
        public BindingArray Array = new();
        /// <summary>
        /// The boxing and unboxing functions used by the factory to incorporate user-defined parameters
        /// </summary>
        public BindingBoxer Boxer = new();
        /// <summary>
        /// A list of methods used to initialize a factory
        /// </summary>
        public IMethodSymbol[] LoadMethods;
        /// <summary>
        /// If this factory should be treated as a root node to be created from the main function
        /// </summary>
        public bool GenerateEntryPoint;
        /// <summary>
        /// A list of all objects created by the factory
        /// </summary>
        public FactoryObject[] Objects;
        /// <summary>
        /// A list of factories dependent on this factory
        /// </summary>
        public IPropertySymbol[] Subfactories;

        /// <summary>
        /// Finds all declared factories within a compilation context
        /// </summary>
        /// <param name="ctx">The compilation context</param>
        /// <returns>The factory objects</returns>
        public static IEnumerable<BindingFactory> ParseAll(Context ctx) {
            BindingFactory obj = null;
            foreach ((INamedTypeSymbol symbol, (INamedTypeSymbol declarativeAttr, INamedTypeSymbol bindingAttr)) in ctx.Types
                .BeginValidation()
                .HasAttribute(ctx.BindingFactoryAttribute, a => ((INamedTypeSymbol) a.ConstructorArguments[0].Value, (INamedTypeSymbol) a.ConstructorArguments[1].Value))
                .WhereValid()) {
                if (obj == null) {
                    obj = new();
                }
                if (!symbol.BeginValidation()
                    .IsClass<INamedTypeSymbol>()
                    .IsNotGenericType<INamedTypeSymbol>()
                    .IsNotAbstractType<INamedTypeSymbol>()
                    .IsPublic()
                    .IsDefaultConstructible<INamedTypeSymbol>()
                    .Require(ctx.Diagnostics)) {
                    continue;
                }
                obj.Symbol = symbol;
                obj.DeclarativeAttribute = declarativeAttr;
                obj.BindingAttribute = bindingAttr;
                int start = ctx.Diagnostics.Count();
                new[] {
                        (declarativeAttr, AttributeTargets.Class),
                        (bindingAttr, AttributeTargets.Property)
                    }.BeginValidation()
                    .Extends(ctx.Attribute)
                    .HasAttribute(ctx.AttributeUsageAttribute, (a, t) => ((int) a.ConstructorArguments.FirstOrDefault().Value) == (int) t)
                    .ContextTrue("AttributeUsage incorrectly set on attribute")
                    .Require(ctx.Diagnostics);
                obj.Array.TryParse(symbol, ctx);
                obj.Boxer.TryParse(symbol, ctx);
                obj.LoadMethods = symbol.GetAllMembers()
                    .OfType<IMethodSymbol>()
                    .BeginValidation()
                    .HasAttribute(ctx.BindingFactoryLoaderAttribute)
                    .IsPublic()
                    .IsInstance()
                    .IsOrdinaryMethod()
                    .IsParameterless()
                    .WhereValid()
                    .StripContext()
                    .ToArray();
                obj.GenerateEntryPoint = symbol.BeginValidation()
                    .HasAttribute(ctx.EntryPointAttribute)
                    .Check();
                obj.Subfactories = symbol.GetAllMembers()
                    .OfType<IPropertySymbol>()
                    .BeginValidation()
                    .HasAttribute(ctx.SubfactoryAttribute)
                    .HasPublicSetter()
                    .WhereValid()
                    .StripContext()
                    .Where(p => p.Type.OriginalDefinition.DEquals(ctx.IBoundFactory_1))
                    .ToArray();
                if (ctx.Diagnostics.Count() == start) {
                    yield return obj;
                    obj = null;
                }
            }
        }

        /// <summary>
        /// Finds all objects created by this factory
        /// </summary>
        /// <param name="ctx">The compilation context</param>
        public void FindObjects(Context ctx) {
            List<FactoryObject> objs = new();
            FactoryObject obj = null;
            foreach ((INamedTypeSymbol symbol, AttributeData attr) in ctx.Types.BeginValidation()
                .HasAttribute(DeclarativeAttribute, a => a)
                .WhereValid()) {
                if (obj == null) {
                    obj = new();
                }
                if (!symbol.BeginValidation()
                    .IsClass<INamedTypeSymbol>()
                    .IsNotGenericType<INamedTypeSymbol>()
                    .IsNotAbstractType<INamedTypeSymbol>()
                    .IsPublic()
                    .IsDefaultConstructible<INamedTypeSymbol>()
                    .Require(ctx.Diagnostics)) {
                    continue;
                }
                obj.ObjectType = symbol;
                if (!obj.ParseAttributeData(ctx, attr)) {
                    continue;
                }
                objs.Add(obj);
                obj = null;
            }
            Objects = objs.OrderBy(o => o.Priority).Select((o, i) => {
                o.Index = i;
                return o;
            }).ToArray();
        }
    }
}
